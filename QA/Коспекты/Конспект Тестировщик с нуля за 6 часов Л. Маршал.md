[LINK TO SOURCE](https://www.youtube.com/watch?v=3kgdKE7ndvI)

# Summary: моё скромное мнение

Видео является очень вольным пересказом книги Святослава Куликова. Как видео-экскурс имеет место быть.

Возможно будет кому-то из только начавших готовиться в качестве "послушать фоном, освежить память". Важно помнить, что не вся информация здесь на 100 % корректна.

При этом есть ряд достаточно спорных моментов. Например, Sanity test назван "санитарным". Подробнее см. в [[Smoke and sanity tests]].

Классификацию автор демонстрировал на примере интеллект-карты, но слишком сумбурно. Рассматривать как какой-то исчерпывающий курс точно не стоит. Тем более, что оно является компиляцией из отдельных видео, выложенных в виде плейлиста на канале автора.

Видео просматривал как "введение в тему" тестирования. С задачей "нахвататься по шапкам" видео помогает справиться.

Сейчас понял, что лучше бы сразу перешел к книге Куликова: и структура точнее, и материал насыщеннее. 

***

# QA & QC

**Хронология развития событий:**
- 60-e — Эпоха исчерпывающего тестирования
- 70-е — Доказательство правильности работы / ошибка — успех
- 80-е — Предупреждение дефектов
- 90-е — Обеспечение качества
- 2000-е — Автоматизация / agile / качество  — клиент

**QA** — это про формирование команды, помещения, парк машин, условия работы и т.д. Т.е. самое высокоуровневое понятие.

**QC** — это про то, что напрямую связано с продуктом: архитектура, требования, … , код.

**Тестирование** — процесс установления соответствия между ожидаемым поведением тестируемого объекта и реальным (фактическим).

**Качество** — совокупность характеристик ПО, относящихся к его способности удовлетворять установленные и предполагаемые потребности. Также это степень, с которой ПО реализует требуемые свойства.

Качество это достаточно субьективное понятие, но есть стандарты ISO или ГОСТ, на которые можно и нужно опираться при оценке качества ПО.

# Модели разработки (0:18:00)

- Водопадная модель.
- V-образная модель.
- Инкрементальная (итеративная) модель.
- Спиральная модель.
- Гибкая модель.
- Модель хаоса.

В реалиях живут по водопадной (ПО для космоса, военно-промышленного комплекса и в целом проекты с жесткой архитектурой), инкрементальной, гибкой и модели хаоса (как правило, стартапы).

**Инкрементальная vs. Итеративная.** 
Разница между инкрементальной и итеративной в следующем. Если первая подразумевает, что идея уже сформировалась и мы просто постепенно реализуем декомпозированную систему, то вторая реализуется при неизвестной полной картине проекта, когда требования и идеи рождаются по мере реализации проекта.

**SCRUM.**
В качестве гибкой модели сейчас наиболее популярен SCRUM. *Agile в чистом виде в природе не встречается.*

Как правило, SCRUM тоже везде со своими особенностями. При этом везде есть стандартные ритуалы: начальные митинги, дейли митинги, ретроспективы и т.д.

Цель спринта — выдать наглядный результат работы. Если показать нечего — значит спринт не оч.

Дейли митинги — что сделал вчера, что сделаю сегодня, какие проблемы.

Свиньи и куры или о ролях в scrum-команде: первые полностью вовлечены в процесс, вторые — нет.

**Модель хаоса.**
**МХ** — решать самые срочные задачи в первую очередь. Периодически все скатываются в МХ. Стартапы вообще живут примерно по ней. Неудобно, стрессово, тестер тут непонятно когда, где и зачем, но всегда очень нужен и во всём виноват.

**Этапы тестирования.**
Любая из моделей состоит из основных этапов тестирования (_кратко_)**:
1. Идея
2. Проработка и анализ требований (_вероятно, тестирование требований_)
3. Передача требований разработчикам (_тестеры в это время пишут чек-листы, кейсы и готовят тестовую доку_)
4. Непосредственно тестирование (_естественно, баг-репорты_)
5. Отчет о проведенном тестировании (_уходит продукт в релиз или нет_).

# Тестирование требований (1:02:07)

Требования делят на прямые и косвенные. 

**Прямые** — явно указаны в спецификации или иной форме указания требований, принятой на проекте. 

**Косвенные** — нечто само собой разумеющееся, действительно очевидное и не требующее пояснений (например, то что при нажатии на красный крестик в верхнем углу окна программа должна закрываться).

Требования являются фундаментом для разработки текст-кейсов, т.к. должны четко описывать ожидаемый результат.

Также требования делят на функциональные и нефункциональные.

**Функциональные** т. — требования к бизнес-логике программы. 

**Нефункциональные** т. — надежность, безопасность, производительность, юзабилити и т.п. Т.е. то, что напрямую не является указанием "какие проблемы и каким образом должна решать программа", но при этом характеризует программу с той или иной стороны.

**Источники требований:**
- Заказчик
- Документы
- Мозговой штурм
- Фокус-группа
- Наблюдение
- Моделирование
- Анкетирование
- Прототип
- Описание
- Нормы
- Лучшие практики
- Конкуренты

**Характеристики требований:**
- Завершенность
- Непротиворечивость
- Корректность
- Недвусмысленность
- Проверяемость
- Атомарность
- Выполнимость
- Обязательность

# Тест план и тест стратегия (1:22:45)

После тестирования требований необходимо планирование, прежде чем начинать тестирование.

“Тест-планы никому не нужны, но само по себе планирование имеет большую ценность”  — народное творчество.

Тест-план бывает в виде мастер-плана, плана и приемо-сдаточного плана. План в целом существует не всегда: всё зависит от организованности команды, требований заказчика и сложившихся традиций.

Планирование могут повесить даже на джуна. В любом случае, каждый планирует свою работу. Наобум ничего не делается.

**План приемо-сдаточных испытаний.** Фактически это аналог отработки акта приема-передачи. Очень похож на смоук-тесты, т.е. это некоторый ограниченный набор проверок. Хотя иногда и встречается очень подробный приемо-сдаточный тест.

**Мастер-план.** Высокоуровневая вещь, в которой ничего подробно не прописывается. Примечательно, что кроме него часто ничего и нет на проекте. Может содержать следующее:

- требования к заводимым дефектам
- условия принятия сборки (фактически, про смоук-тесты)
- критерии принятия продукта к релизу
- инструменты

**План.** Обычный план делается всегда. Просто не всегда на бумаге. (_Тестировщик без бумажки — хреновый тестировщик!_). Если тест-план не нужен никому, кроме вас, то это не повод его не делать. На этапе планирования вы можете уже разложить проект по полочкам и понять что и как будете тестировать. Во-вторых, план не должен быть статичным, он должен и будет меняться.

Важно, что хороший план — фактически готовый отчет о тестировании.

Есть классический вариант, что писать в тест план:

1. Что надо тестировать?
2. Что будем тестировать?
3. Как будем тестировать?
4. Когда?
5. Критерии сдачи
6. Критерии приемки

В целом, можно вносить все, что угодно, если это не противоречит здравому смыслу.

**План на примере автора:**

1. Перечень работ. _Области, которые будут и НЕ будут протестированы._
2. Критерии качества и оценки. _Тема сложная, больше для менеджменат. Но для себя: например, ошибки на этапе релиза как понижающий коэффициент; объем выполняемых тестов; соотнести их с количеством функциональных требований; количество отклоненных баг-репортов._
3. Оценка рисков. _Также больше для лидов. Но для себя: какие риски могут быть связаны с работой? Например, ваши навыки, может стоит где-то доучиться._
4. Документация. _Какую документацию будете использовать? Откуда будете исходить: чек-листы или тест-кейсы? Может проработать шаблон или критерии для них? Как часто должны тест-кейсы пересматриваться? Будет ли ревью внутри команды? Что насчет приемки тест-кейсов: может быть джунов стоит контроллить в какие-то сроки?_
5. Тестовая стратегия. _Тестовая стратегия это часть тест-плана. Содержит методы тестирования, уровни тестирования, виды тестирования. Можно разбить проект по модулям и проработать отдельно каждый модуль. Также может содержать информацию о регрессионном тестировании, его объем и содержание. Может содержать метрики по передаче тест-кейсов, например, в регресс. Может содержать описание процесса отслеживания заведенных дефектов, например, регламент отработки дефектов вернувшихся от разработчиков._
6. Ресурсы. _Человеческие, аппаратные, программные._
7. Расписание. _Приблизительная оценка сроков на ту или иную часть запланированной работы._

Не стесняйтесь делать тест-план даже если вы джун! Просите время на подготовку тест-плана. Если проект стартовал — то можно уже даже в проекте собрать тест-план, если его еще не было.

# Виды тестирования (1:51:37)

На собеседовании чаще всего хотят слышать классификацию на виды тестирования по объектам:

1. **Функциональные**
    1. Функциональное тестирование: _что будет делать ваш продукт._
    2. GUI тестирование элемента интерфейса: _если элемент интерфейса имеет какое-то поведение. Например, это какие-либо реакции на наведение, нажатие и т.п._
    3. Безопасность (опционально, _например, если продукт заточен на обеспечение безопасности_)
2. **Нефункциональные**
    1. Безопасность
    2. Тестирование интерфейса
        1. _Соответствие дизацну_
        2. _Внешний вид_
        3. _Соблюдение единого стиля_
    3. Юзабилити тестирование
        1. _Как быстро пользователь достигнет цели_
        2. _Как долго вспоминать то, чему научился_
        3. _Размер кнопок_
        4. _Часто ли пользователю нужно выбирать_
        5. _Большие ли списки_
        6. _Порог вхождения_
    4. т-е Локализации
    5. Интернационализация (_подразумевает, что заранее предусмотрена возможность локализации в принципе. Т.е. изменение языка или чего-то еще не приведет к необходимости кардинальных изменений.)_
    6. Конфигурационное тестирование
    7. т-е Совместимости (_пример, кроссбраузерное тестирование)_
    8. Инсталляционное
        1. _Установка_
        2. _Обновление_
        3. _Удаление_
    9. Производительности
        1. _Нагрузочное: оценка работы при заданной нагрузке_
        2. _Стрессовое: оценка запаса прочности_
        3. _Стабильности (надежности): нагрузка на длительном промежутке времени._
        4. _Масштабируемости (например, по железу и нагрузке: насколько сложно масштабировать продукт)_
        5. _Объемное (большими объемами входных данных)_
        6. _Конкуррентное_
    10. Тестирование на отказ и восстановление (_например, мобильная игра во время поступления звонка)_
    11. Тестирование документации

Перечисленного выше более чем достаточно, для прохождения собеседования. _ОДНАКО_ _Это не исчерпывающий перечень, классификация огромная и может эволюционировать. Единого стандарта нет!_

Классификация очень поможет при составлении плана: на нее можно опираться при определении “Что тестировать?”.

# Подробнее про функциональное тестирование (2:14:00)

Функциональное тестирование — большинство тестеров, особенно джунов заняты именно функциональными тестами.

Функциональное тестирование подразумевает, что вам необходимо проверить весь функционал программы на соответствие реальности ожидаемому поведению согласно спецификации (требованиям).

_Требования -> Входные данные -> Выходные данные -> Прохождение сценариев -> Сравнение результатов._

В итоге мы должны понимать, какой функционал уже реализован и насколько корректно он работает.

Плюсы ФТ: функциональные тесты это фактически действия пользователей.  
Минусы ФТ: часто тестировщики уходят в очень большое количество тестовых данных, пытаясь испробовать все что можно. _Из-за этого упускается из вида то, что тестирование это про то, как пользователь будет использовать софт. При этом ФТ часто жрет сроки с точки зрения ухода в избыточное тестирование._

# Тестирование локализации и интернационализации (2:23:15)

Как правило, требуется пул внешних специалистов: копирайтеры-носители, юристы и т.д. Т.к. важна работа с символикой, религиозной и правовой составляющей.

Тестирование интернационализации — превентивное, вы заранее продумываете тесты, чтобы предугадать проблемы.

Тестирование локализации — проверка результатов перевода и приведения к каким-то локальным нормам.

# Виды тестирования связанные с изменениями (2:33:44)

Их 4 основных вида:

1. **Дымовое тестирование (смоук-тест)**  
    Нужно в случае выхода новой сборки: “А это вообще работает?”. Проверяется критически важный функционал в формате end-to-end (полный путь потенциального пользователя). Если тест не прошел — то дальнейшее тестирование невозможно в принципе.
2. **Регрессионное тестирование  
    **Продукт уже тестировался, но сейчас есть доработка. При этом доработка, возможно, оттестирована. Но она могла сломать старый код (функционал). Нужно проверить весь старый функционал.
3. **Тестирование сборки**  
    Фактически это максимально возможное тестирование очередного билда (сборки) продукта.
4. **Санитарное тестирование**  
    Тестирование конкретного участка функционала, какой-то “болезненной” части. Либо очень важной, либо часто падающей.
5. _Ретесты (вне классификаций). Это процесс проверки функционала, в котором был отловлен и устранен баг._

# Уровни тестирования (2:41:50)

Классическое деление на 4 этапа:
1. **Модульное тестирование**  
    Юнит-тесты. Проверка атомарных частей кода. Как правило, работа разрабов. Обязательно метод белого ящика.
2. **Интеграционное тестирование**  
    Тестирование взаимодействия отдельных частей приложения. Интеграционные тесты, как правило, напрашиваются на автоматизацию.
3. **Системное тестирование**  
    Комплекс end-to-end тестов, проверяющих работу системы в целом.
4. **Приемочное тестирование**  
    Нечасто выделяется в уровень тестирования. Это некоторый специфический этап: проводится при сдаче продукта.

# Методы тестирования (2:52:05)

Насколько глубоко вы можете погрузиться в тестирование? Есть ли доступ к коду, БД, железному уровню?

1. **Черный ящик**  
    У вас есть только пользовательское представление. Т.е. вы даете что-то на вход, смотрите что получилось на выходе.
2. **Белый ящик**  
    Есть полный доступ: к коду, к БД, к системе.
3. **Серый ящик** (_ОЧЕНЬ холиварная тема)  
    Четкого определения нет. ISTQB на этот счет вообще не закрепляли какого-то определения. По факту это “народный фольклор”. По мнению автора, серый ящик подразумевает доступ туда, куда нет доступа у рядового пользователя. Когда есть какой-то доступ к информации, которой нет у пользователя. Например, просто чтение БД._

# Направления тестирования (2:59:30)

1. **Статическое** _Без запуска кода на исполнение._  
    Направленно на предотвращение дефектов.  
    Во-первых, это тестирование требований.  
    Во-вторых, обзор архитектуры проекта. Требует высокой квалификации QA-инженера.  
    В-третьих, это проверка макетов.
2. **Динамическое** _С запуском кода на исполнение._  
    Поиск дефектов в уже существующем приложении. Как правило, состоит в сопоставлении реального и ожидаемого поведения приложения.

# По степени удаленности (3:08:30)

Чаще всего применяется в игровой индустрии.
1. **Альфа-тестирование**  
    Подразумевает “сырой”, но существующий продукт. Происходит силами команды с минимальным привлечением сторонних пользователей.
2. **Бета-тестирование**  
    Проверка прошедшего “альфу” продукта. Проводится силами внешних пользователей. Закрытое — избранной фокус-группой. Открытое — любым желающим пользователем.

# По ожидаемому поведению (3:19:50)

1. **Позитивное тестирование**  
    Проверка идеального поведения ПО. Производится путем использования корректных данных и корректных запросов от ПО с точки зрения требований.
2. **Негативное тестирование**  
    Некорректные запросы и нетипичные воздействия с точки зрения требований. Программа при этом не должна сломаться, она должна адекватно отработать исключительную ситуацию.

# Артефакты тестирования: чек-листы, тест-кейсы (3:25:42)

**Артефакт тестирования** — любой документ, который вы заводите в ходе работы.

Чеклист как сущность состоит из (_не исчерпывающий список_):

1. Номер
2. Описание проверки
3. Статус
    1. _Passed_
    2. _Failed_
    3. _Skipped_
    4. _No run_
    5. _Blocked_
4. Комментарий

Чек-лист —  вольная форма, можно городить что душе угодно.

При составлении чек-листов нужно избегать мусорных слов. Например, “проверить…” в каждом пункте.

Существует идея, когда каждый тест должен быть атомарным, но случается, что тесты зависят от других тестов. Например, авторизация. С этим придется мириться. Если проведение теста невозможно, то статус _blocked._

Возможен вариант построения чек-листов на базе интеллект-карт. Интересен в первую очередь визуализацией.

Может быть достаточно подробной таблицей, близкой по формату к тест-кейсу. (_Кмк, оверхэд…)_

**Плюсы:**
1. Гибкость
2. Простота создания
3. Простота визуализации
4. Расширение тестового покрытия

**Минусы:**
1. Каждый делает по своему
2. Неопределенность тестовых данных
3. Неэффективен для джунов
4. Высокая вероятность разночтения

# Тест-кейсы (3:47:41)

**Тест-кейс** — набор входных значений, предусловий выполнения, ожидаемых результатов и пост-условий выполнения, разработанный для определенной цели или тестового условия, _таких как выполнение пути программы_ или же для проверки соответствия определенному требованию.

**Атрибуты тест-кейса:**
1. Номер
2. Заголовок
3. Предусловия
4. Шаги проверки
5. Ожидаемый результат
6. Статус
7. Модель
8. Приоритет
9. Связанное требование

Шаги проверки должны быть понятны, не должно оставаться разночтений. Не должно быть шансов подумать о чем-то ином, чем то, что написано. Не рекомендуется присать тестовые данные в шаги првоерки.

**Правила:**

1. **Независимость.**  
    Тест-кейс должен быть независимым, но на практике так получается не всегда
2. **Однозначность.**  
    Не должно оставаться вообще никаких разночтений.
3. **Полнота**  
    Никоо не должен додумывать или что-то спрашивать (где-то добывать информацию)
4. **Обезличенность**  
    ”Нажми на кнопку” — плохо. “Нажать на кнопку” — хорошо.
5. **Упрощай**  
    Не нужно уходить в сверхспецифичность и словоблудие
6. **1 кейс = 1 цель**  
    Вероятно в рамках одного тест-кейса произойдет проверка нескольких состояний или путей. Но цель должна быть всегда одна.

**Разделение по уровням** (_не канонично, фантазии автора?)_:
1. **Высокоуровневый —** поведение больше похоже на чек-листы, можно еще раскрыть и детализировать. _Потенциально, это сырые низкоуровневые тесты._
2. **Низкоуровневый —** нормальный тест-кейс, детализированный в рамках описанных выше правил.

Для ведения тест-кейсов актуальны ровно теже программы, что и для чек-листов.

# Техники тест-дизайна (4:06:51)

Книга Ли Копланда (англ). Это родоначальник техник тест-дизайна. Техники предназначены для определенных ситуаций, это не совсем поле для выбора.

1. **Доменный анализ  
    **Это комбинация из “классы эквивалентности”, “граничные значения” и “попарное тестирование”.  
    На практике очень легко ошибиться, применяется не часто: если только сильно прокачаешься в остальных техниках, на уровне “тест-аналитика”, уже можно попробовать.
2. **Сценарная  
    **Подразумевает разработку тестов на основании сценариев действий пользователя.
3. **Классы эквивалентности  
    **Подразумевает разбиение диапазонов данных на некие эквивалентные по смыслу значения с единым ожидаемым поведением.
4. **Граничные значения  
    **Проверка границ избранных диапазонов, например, по классам эквивалентности. Проверка производится в стиле “0±1”.
5. **Таблица принятия решений**
6. Перебираются некие условия, сфоримрованные в рамках комбинаторики.
7. . **ADHOC  
    **Без доков, по наитию, интуитивно. Как реальный пользователь. Никто не читает инструкций. При этом цели использования должны быть абсолютно реальны, без фанатизма. Нет задачи “ща все сломаю”.
8. **Попарное тестирование  
    **Опирается на комбинаторику. Сокращение числа проверок от “уникальное значение для трех полей” до “уникальное по двум полям” дает вероятность отлова ошибок в 95-97%. Это сильно сокращает время. Смысл в формировании “уникальных пар”. _НУЖНО УТОЧНИТЬ, ОБЪЯСНИЛ ОЧЕНЬ ПУТАНО!  
    Есть спец-софт для формирования этих уникальных комбинаций. Вручную никто не заморачивается._
9. **Предугадывание ошибок  
    **Техника для опытных тестеров с чутьем. Можно сразу бить туда, где болит “у всех”.
10. **Причина/следствие  
    **”Что-то делаем — Что-то получается”
11. **Состояния и переходы**

# Дефект, поиск багов, баг-репорт (4:43:40)

**Дефект (баг)** — несовершенство или недостаток в рабочем продукте, если он не соответствует его требованиям или спецификациям.

По факту, это несоответствие между ожидаемым результатом и фактическим.

**Баг-репорт** — документ, описывающий ситуацию или последовательность действий, приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.

Кто заводит баг-репорты:
- QA
- Разработчики
- Тех поддержка
- Продавцы
- Заказчик
- Пользователи

Баг-трекеры:
- Jira
- Redmine
- Mantis
- Excel (_ну, с натяжечкой_)

Локализация дефекта:
- Выявить причины возникновения дефекта (бэк, фронт, на кого вешать багу)
- Исследовать окружение (воспроизвести на разных окружениях и системах)
- Проверить в разных версиях ПО
- Проанализировать возможность влияния найденного дефекта на другие области

**Атрибуты баг-репорта:**
- Основные
    - Идентификатор
    - Заголовок
    - Шаги воспроизведения
    - Актуальный результат
    - Ожидаемый результат
    - Окружение
    - Критичность
    - Приоритет
- Дополнительные
    - Приложения (скрины, видео)
    - Возможность обойти баг
    - Воспроизводимость
    - Комментарии

Могут отличаться в конкретных компаниях, но в целом можно опираться на вышеописанный подход.

**Заголовок состоит из (что/где/когда):**
1. Что произошло?
2. Где произошло?
3. При каких условиях?

**Шаги воспроизведения:**
- Описывайте каждое действие в отдельном шаге
- Описывайте безличные формулировки, призывающие к действию
- Описывайте каждый шаг, пока не столкнетесь с дефектом
- Найдите кратчайший путь воспроизведения
- Найдите точный путь воспроизвдения
- Пишите так, чтобы любой новичок мог его воспроизвести

**Severity (Критичность):**
В компаниях должен быть регламент по установке критичности для багов.
1. **Blocker**  
    Блокирующая ошибка. После этого дефекта невозможно продолжать работать с системой в целом, ключевой функционал недоступен. Если есть обходной путь, то переходит в critical.
2. **Critical**  
    Неправильно работающая ключевая бизнес-логика. Дыра в системе безопасности. Или проблема руинит часть системы или систему полностью.
3. **Major**  
    Часть основной бизнес-логики работает некорректно. Есть возможность работать с тестируемым объектом на других данных. Если работает в одном случае, но падает в другом — то major.
4. **Minor**  
    Не нарушает бизнес-логику, проблема в UI/UX и т.п.
5. **Trivial**  
    Не затрагивает функционал системы; приводит к ошибкам в сторонних программах, но не в нашей; опечатки и пропуски пробелов; незначительные отклонения верстки.

Влияние на нашу систему (критичность) не равно срочности! Вполне возможно, что тривиал будет НЕВЕРОЯТНО срочным с точки зрения бизнеса!

**Приоритет:**
1. High — как можно быстрее
2. Normal — обязательно решение
3. Low — не требует срочного решения

У новичков очень часто проблемы с выставлением Severity и Priority. Если не шаришь — дергай за рукава “умных”.

**Советы:**
- Упрощайте шаги. Чем длиннее шаг/описание, тем хуже
- Проверьте на дубликаты
- Убирайте лишние шаги
- Убедитесь, что репорт понятен
- 1 отчет на 1 дефект
- Прослеживаемость с другими артефактами
- Проверьте грамотность

**Основные ошибки:**
- недостаточно предоставленных данных для воспроизведения бага, или баг воспроизводится только при конкретных обстоятельствах, но они не указаны
- название репорта и ожидаемый результат не соответствуют друг другу
- завышение/занижение Severity
- неверное употребление терминов
- сложные речевые обороты
- отсутствует ожидаемый результат
- критика программистов

# Жизненный цикл дефекта (5:28:00)

![Скриншот презентации автора](https://i2.paste.pics/76d4fbcefc4991f0df3960dab51d5795.png)

**Когда баг не будут исправлять?**
1. Программист не смог воспроизвести баг
2. Нет актуального поведения
3. Нет ожидаемого поведения
4. Репорт написан расплывчато/непонятно
5. Нет необходимых скриншотов/логов
6. QA не смог объяснить важность проблемы

**Релиз бага —** когда программное обеспечение или приложение передается группе тестирования, зная, что дефект присутствует в выпуске. При этом приоритет и серьезность ошибки низкие.

**Утечка бага —** когда баг обнаруживается конечными пользователями или заказчиками, но не группой тестирования во время тестов.

**Откуда берутся баги:**
1. Недопонимание
2. Ошибки программирования
3. Сжатые сроки
4. Изменение в требованиях
5. Сложность ПО

## Отчет о тестировании (5:38:06)

Встречается редко в продуктовых компаниях, чаще на аутсорс. *Автор приводит презентацию с некоторыми пояснениями. В целом, малоинформативно.*

**Отчет о результатах тестирования** — часть тестовой документации, включающая в себя описание процесса тестирования, суммарную информацию о протестированных за подотчётный период билдах, информацию о деятельности тестировщиков, а также другие статистические данные.

**Цель отчета** — предоставить лицам, заинтересованным в проекте, полную и объективную информацию о текущем состоянии качества продукта. Эта информация выражается в конкретных фактах и цифрах.

Периодичность отчетов. Созадется по некоторому расписанию, частота выпусков зависит от решения команды/руководства.

**Структура отчета:**
- Команда тестировщиков — перечисляются действующие лица и их должности.
- Описание процесса тестирования — методы, техники, инструменты и т.п.
- Краткое описание — какие билды, есть ли прогресс или регресс, по сути саммари, которое должно позволить менеджеру вообще не читать остальной отчёт без острой на то необходимости.
- Расписание — кто, когда и что делал.
- Рекомендации — важная информация для лица, заинтересованного в отчете. Здесь же рекомендация о передаче, например, в прод.
- Статистика по ошибкам
- Список новых ошибок — баги за текущий подотчетный период.
- Статистика по всем ошибкам — баги за весь период.